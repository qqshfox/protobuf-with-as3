// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.
// http://code.google.com/p/protobuf/
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Author:  Robert Blackwood (ported from Kenton's)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.

#include <google/protobuf/compiler/as3/as3_file.h>
#include <google/protobuf/compiler/as3/as3_enum.h>
#include <google/protobuf/compiler/as3/as3_service.h>
#include <google/protobuf/compiler/as3/as3_extension.h>
#include <google/protobuf/compiler/as3/as3_helpers.h>
#include <google/protobuf/compiler/as3/as3_message.h>
#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/stubs/strutil.h>

namespace google {
namespace protobuf {
namespace compiler {
namespace as3 {

FileGenerator::FileGenerator(const FileDescriptor* file)
  : file_(file),
    as3_package_(FileAs3Package(file)),
    classname_(FileClassName(file)) {}

FileGenerator::~FileGenerator() {}

bool FileGenerator::Validate(string* error) {
  // Check that no class name matches the file's class name.  This is a common
  // problem that leads to As3 compile errors that can be hard to understand.
  // It's especially bad when using the java_multiple_files, since we would
  // end up overwriting the outer class with one of the inner ones.

  //bool found_conflict = false;
  //for (int i = 0; i < file_->enum_type_count() && !found_conflict; i++) {
  //  if (file_->enum_type(i)->name() == classname_) {
  //    found_conflict = true;
  //  }
  //}
  //for (int i = 0; i < file_->message_type_count() && !found_conflict; i++) {
  //  if (file_->message_type(i)->name() == classname_) {
  //    found_conflict = true;
  //  }
  //}
  //for (int i = 0; i < file_->service_count() && !found_conflict; i++) {
  //  if (file_->service(i)->name() == classname_) {
  //    found_conflict = true;
  //  }
  //}

  //if (found_conflict) {
  //  error->assign(file_->name());
  //  error->append(
  //    ": Cannot generate As3 output because the file's outer class name, \"");
  //  error->append(classname_);
  //  error->append(
  //    "\", matches the name of one of the types declared inside it.  "
  //    "Please either rename the type or use the as3_outer_classname "
  //    "option to specify a different outer class name for the .proto file.");
  //  return false;
  //}

  return true;
}

void FileGenerator::Generate(io::Printer* printer,int message_number) {
  // We don't import anything because we refer to all classes by their
  // fully-qualified names in the generated source.
  
	
	printer->Print("// Generated by the protocol buffer compiler.  DO NOT EDIT!\n"
				   "\n");
	printer->Print("package $package$ {\n"
				   "\n",
				   "package", as3_package_);
	printer->Indent();

	MessageGenerator(file_->message_type(message_number)).Generate(printer);
	
	printer->Outdent();
	printer->Print("\n}");
}

template<typename GeneratorClass, typename DescriptorClass>
static void GenerateSibling(const string& package_dir,
                            const string& as3_package,
                            const DescriptorClass* descriptor,
                            OutputDirectory* output_directory,
                            vector<string>* file_list) {
  string filename = package_dir + descriptor->name() + ".as";
  file_list->push_back(filename);

  scoped_ptr<io::ZeroCopyOutputStream> output(
    output_directory->Open(filename));
  io::Printer printer(output.get(), '$');
	
	printer.Print("// Generated by the protocol buffer compiler.  DO NOT EDIT!\n"
				   "\n");
	printer.Print("package $package$ {\n"
				   "\n",
				   "package", as3_package);
	printer.Indent();
	
	GeneratorClass(descriptor).Generate(&printer);
	
	printer.Outdent();
	printer.Print("\n}");
}

void FileGenerator::GenerateSiblings(const string& package_dir,
                                     OutputDirectory* output_directory,
                                     vector<string>* file_list) {
  //if (file_->options().java_multiple_files()) {
    for (int i = 0; i < file_->enum_type_count(); i++) {
      GenerateSibling<EnumGenerator>(package_dir, as3_package_,
                                     file_->enum_type(i),
                                     output_directory, file_list);
    }
    for (int i = 0; i < file_->message_type_count(); i++) {
      //GenerateSibling<MessageGenerator>(package_dir, as3_package_,
//                                        file_->message_type(i),
//                                        output_directory, file_list);
		//This is awesomly bad... supports only 3 levels of nesting :( It's got to be changed to a recursive call
		for (int j = 0; j < file_->message_type(i)->nested_type_count(); j++) {
			GenerateSibling<MessageGenerator>(package_dir, as3_package_,
											  file_->message_type(i)->nested_type(j),
											  output_directory, file_list);
			for (int k = 0; k < file_->message_type(i)->nested_type(j)->nested_type_count(); k++) {
				GenerateSibling<MessageGenerator>(package_dir, as3_package_,
												  file_->message_type(i)->nested_type(j)->nested_type(k),
												  output_directory, file_list);
			}
			
		}
    }
    for (int i = 0; i < file_->service_count(); i++) {
      GenerateSibling<ServiceGenerator>(package_dir, as3_package_,
                                        file_->service(i),
                                        output_directory, file_list);
    }
 // }
}

}  // namespace as3
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
